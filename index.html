<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Exploding Sphere Example</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
// Set up the Three.js scene and renderer
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30;
var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Create the circle of 20 spheres
var circleRadius = 10;
var sphereRadius = 0.5;
var spheres = [];
for (var i = 0; i < 20; i++) {
    var hue = THREE.Math.randFloat(0.5, 0.8);
    var saturation = THREE.Math.randFloat(0.5, 1.0);
    var lightness = THREE.Math.randFloat(0.3, 0.7);
    var color = new THREE.Color().setHSL(hue, saturation, lightness);
    var sphere = new THREE.Mesh(new THREE.SphereGeometry(sphereRadius, 32, 32), new THREE.MeshPhongMaterial({ color: color }));
    var angle = (i / 20) * Math.PI * 2;
    sphere.position.x = Math.cos(angle) * circleRadius;
    sphere.position.y = 5;
    sphere.position.z = Math.sin(angle) * circleRadius;
    spheres.push(sphere);
    scene.add(sphere);
}
    
// Add 100 small red cubes moving back and forth between different spheres
var numCubes = 100;
var cubes = [];
for (var i = 0; i < numCubes; i++) {
    var cube = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
    var startSphere = spheres[THREE.Math.randInt(0, spheres.length - 1)];
    var endSphere = spheres[THREE.Math.randInt(0, spheres.length - 1)];
    cube.userData = {
        startSphere: startSphere,
        endSphere: endSphere,
        progress: 0,
        direction: 1
    };
    cube.position.copy(startSphere.position);
    cubes.push(cube);
    scene.add(cube);
}


      
// Create the inner circle of 20 spheres
var innerCircleRadius = 5;
var innerSpheres = []; 
for (var i = 0; i < 80; i++) {
    var hue = THREE.Math.randFloat(0.5, 0.8);
    var saturation = THREE.Math.randFloat(0.5, 1.0);
    var lightness = THREE.Math.randFloat(0.3, 0.7);
    var color = new THREE.Color().setHSL(hue, saturation, lightness);
    var sphere = new THREE.Mesh(new THREE.SphereGeometry(sphereRadius, 32, 32), new THREE.MeshPhongMaterial({ color: color }));
    var angle = (i / 20) * Math.PI * .5;
    sphere.position.x = Math.cos(angle) * innerCircleRadius;
    sphere.position.y = 5;
    sphere.position.z = Math.sin(angle) * innerCircleRadius;
    innerSpheres.push(sphere);
    scene.add(sphere);
}
      
// Create a sphere geometry
const geometry = new THREE.SphereGeometry(5, 32, 32);

// Create a CanvasTexture object with a gradient fill
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const context = canvas.getContext('2d');
const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
gradient.addColorStop(0, 'blue');
gradient.addColorStop(1, 'purple');
context.fillStyle = gradient;
context.fillRect(0, 0, canvas.width, canvas.height);
const gradientTexture = new THREE.CanvasTexture(canvas);

// Set the material's gradient texture and map properties
var material = new THREE.MeshBasicMaterial({
  map: gradientTexture
});

// Set the material's opacity and transparent properties
material.opacity = 0.6;
material.transparent = true;      
      
// Create a mesh and add it to the scene
var sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);

// Create an ambient light
var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambientLight);

// Create a directional light
var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(0, 10, 0);
scene.add(directionalLight);
      
// Create a second directional light
var directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
directionalLight2.position.set(0, -10, 0);
directionalLight2.target.position.set(0, 0, 0);
scene.add(directionalLight2);
scene.add(directionalLight2.target);

      


// Animate the spheres falling and rising in a wave motion and make random spheres flicker
var time = 0;
function animate() {
    requestAnimationFrame(animate);

    // Rotate the circles along the x axis
    for (var i = 0; i < spheres.length; i++) {
        spheres[i].rotation.x += 0.01;
    }

    // Animate the circle of spheres in a wave motion
    for (var i = 0; i < spheres.length; i++) {
        var sphere = spheres[i];
        var angle = (i / 20) * Math.PI * 2;
        var offset = Math.sin(time + angle) * 2;
        sphere.position.y = offset;
    }
  
  

        // Animate the inner circle of spheres in the opposite wave motion
        for (var i = 0; i < innerSpheres.length; i++) {
        var sphere = innerSpheres[i];
        var angle = (i / 20) * Math.PI * 2;
        var offset = Math.sin(-time + angle) * 2
        sphere.position.y = offset;
    }
  
for (var i = 0; i < cubes.length; i++) {
    var cube = cubes[i];
    var closestSphere = spheres[0];
    var closestDistance = cube.position.distanceTo(closestSphere.position);
    for (var j = 1; j < spheres.length; j++) {
        var sphere = spheres[j];
        var distance = cube.position.distanceTo(sphere.position);
        if (distance < closestDistance) {
            closestSphere = sphere;
            closestDistance = distance;
        }
    }
    if (cube.userData.targetSphere == null) {
        cube.userData.targetSphere = closestSphere;
    }
    if (cube.userData.targetSphere != closestSphere) {
        cube.userData.targetSphere = closestSphere;
        cube.userData.time = 0;
    }
    if (cube.userData.time == null) {
        cube.userData.time = 0;
    }
    cube.userData.time += 0.005;
    var noise = new THREE.Vector3(
        THREE.Math.randFloat(-1, 1),
        THREE.Math.randFloat(-1, 1),
        THREE.Math.randFloat(-1, 1)
    ).normalize().multiplyScalar(Math.sin(cube.userData.time) * 2 + 1);
    cube.position.lerpVectors(cube.userData.targetSphere.position, closestSphere.position.clone().add(noise), cube.userData.time);
}



    // Rotate the camera based on the mouse position
    camera.position.x += ( mouseX - camera.position.x ) * 0.05;
    camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

    camera.lookAt( scene.position );

    renderer.render(scene, camera);

    time += 0.05;
}

// Add event listeners for the mouse movements
var mouseX = 0, mouseY = 0;
var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;
document.addEventListener('mousemove', onDocumentMouseMove, false);

function onDocumentMouseMove(event) {
    mouseX = (event.clientX - windowHalfX) / 10;
    mouseY = (event.clientY - windowHalfY) / 10;
}
      

animate();



</script>
  </body>
</html>
